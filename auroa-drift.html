<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Aurora Drift</title>
<style>
  /* Reset & base */
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #0ff;
    user-select: none;
  }

  #game-container {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #000;
  }

  canvas {
    display: block;
    background: transparent;
  }

  /* Start & Game Over screens */
  #start-screen, #gameover-screen {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: #0ff;
    text-align: center;
    user-select: none;
    mix-blend-mode: screen;
    text-shadow:
      0 0 6px #0ff,
      0 0 20px #0ff,
      0 0 30px #0ff;
  }
  #start-screen h1, #gameover-screen h1 {
    font-size: 4vw;
    margin-bottom: 1rem;
    letter-spacing: 0.2em;
  }
  #start-screen p, #gameover-screen p {
    font-size: 1.3vw;
    margin-bottom: 2rem;
  }
  button {
    cursor: pointer;
    background: transparent;
    border: 2px solid #0ff;
    color: #0ff;
    font-size: 1.5vw;
    padding: 0.6em 2em;
    border-radius: 5px;
    transition: all 0.3s ease;
    letter-spacing: 0.1em;
  }
  button:hover, button:focus {
    background: #0ff;
    color: #000;
    outline: none;
  }

  /* Responsive font sizes */
  @media(max-width: 600px) {
    #start-screen h1, #gameover-screen h1 {
      font-size: 10vw;
    }
    #start-screen p, #gameover-screen p {
      font-size: 4vw;
    }
    button {
      font-size: 5vw;
      padding: 0.8em 3em;
    }
  }
</style>
</head>
<body>
<div id="game-container">
  <canvas id="game-canvas"></canvas>

  <div id="start-screen">
    <h1>Aurora Drift</h1>
    <p>Use WASD to pilot your glowing ship.<br>Survive as long as you can against asteroids & enemies.</p>
    <button id="start-btn">START</button>
  </div>

  <div id="gameover-screen" style="display:none;">
    <h1>GAME OVER</h1>
    <p id="final-score"></p>
    <button id="restart-btn">RESTART</button>
  </div>
</div>

<script>
(() => {
  'use strict';

  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  let W, H;

  // === UTILS ===
  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }
  function distance(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
  }
  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  // === GLOBALS ===
  const keys = { w:false, a:false, s:false, d:false };
  let gameState = 'start'; // 'start', 'playing', 'gameover'
  let score = 0;
  let highScore = 0;

  // === RESIZE ===
  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * devicePixelRatio;
    canvas.height = H * devicePixelRatio;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }
  window.addEventListener('resize', resize);
  resize();

  // === GALAXY BACKGROUND ===
  class Star {
    constructor() {
      this.reset();
    }
    reset() {
      this.x = Math.random() * W;
      this.y = Math.random() * H;
      this.size = Math.random() * 1.2 + 0.2;
      this.speed = this.size * 0.6;
      this.brightness = Math.random();
      this.twinkleSpeed = randomRange(0.002, 0.008);
      this.twinklePhase = Math.random() * Math.PI * 2;
    }
    update() {
      this.x -= this.speed;
      if (this.x < 0) this.x = W;
      this.twinklePhase += this.twinkleSpeed;
      this.brightness = 0.5 + 0.5 * Math.sin(this.twinklePhase);
    }
    draw() {
      const rad = this.size;
      const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, rad*6);
      gradient.addColorStop(0, `rgba(180,230,255,${this.brightness})`);
      gradient.addColorStop(1, 'rgba(180,230,255,0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(this.x, this.y, rad*6, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = `rgba(180,230,255,${this.brightness})`;
      ctx.beginPath();
      ctx.arc(this.x, this.y, rad, 0, Math.PI*2);
      ctx.fill();
    }
  }

  const stars = [];
  for(let i=0; i<200; i++) stars.push(new Star());

  // === PARTICLE SYSTEM ===
  class Particle {
    constructor(x,y,dx,dy,radius,color,life) {
      this.x = x;
      this.y = y;
      this.dx = dx;
      this.dy = dy;
      this.radius = radius;
      this.color = color;
      this.life = life;
      this.maxLife = life;
    }
    update() {
      this.x += this.dx;
      this.y += this.dy;
      this.life--;
      this.radius *= 0.95;
    }
    draw() {
      const alpha = this.life / this.maxLife;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 10 * alpha;
      ctx.fillStyle = this.color;
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
    get alive() {
      return this.life > 0 && this.radius > 0.1;
    }
  }

  // === SPACESHIP ===
  class Ship {
    constructor() {
      this.x = W/2;
      this.y = H/2;
      this.radius = 18;
      this.speed = 5;
      this.velX = 0;
      this.velY = 0;
      this.maxSpeed = 7;
      this.acceleration = 0.4;
      this.friction = 0.15;
      this.glowColor = 'cyan';
      this.trail = [];
      this.trailMax = 15;
      this.shield = 0; // frames of shield active
      this.speedBoost = 0; // frames of speed boost active
    }
    update() {
      // Movement input
      if (keys.w) this.velY -= this.acceleration;
      if (keys.s) this.velY += this.acceleration;
      if (keys.a) this.velX -= this.acceleration;
      if (keys.d) this.velX += this.acceleration;

      // Clamp speed and apply friction
      this.velX = lerp(this.velX, 0, this.friction);
      this.velY = lerp(this.velY, 0, this.friction);

      // Speed boost effect
      let maxSpd = this.maxSpeed;
      if(this.speedBoost > 0) {
        maxSpd = this.maxSpeed * 1.8;
        this.speedBoost--;
      }

      // Clamp velocity
      this.velX = Math.max(-maxSpd, Math.min(maxSpd, this.velX));
      this.velY = Math.max(-maxSpd, Math.min(maxSpd, this.velY));

      // Update position
      this.x += this.velX;
      this.y += this.velY;

      // Clamp position inside screen
      this.x = Math.min(Math.max(this.radius, this.x), W - this.radius);
      this.y = Math.min(Math.max(this.radius, this.y), H - this.radius);

      // Trail particles
      this.trail.push({x: this.x, y: this.y});
      if(this.trail.length > this.trailMax) this.trail.shift();

      // Shield countdown
      if(this.shield > 0) this.shield--;
    }
    draw() {
      // Draw glowing trail
      for(let i=0; i < this.trail.length; i++) {
        const pos = this.trail[i];
        const alpha = i / this.trail.length;
        ctx.shadowColor = this.glowColor;
        ctx.shadowBlur = 20 * alpha;
        ctx.fillStyle = `rgba(0,255,255,${alpha * 0.3})`;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 12 * alpha, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Ship body (triangle)
      ctx.save();
      ctx.translate(this.x, this.y);

      // Calculate rotation angle based on velocity for dynamic feeling
      const angle = Math.atan2(this.velY, this.velX) + Math.PI / 2;
      ctx.rotate(angle);

      // Neon glow
      ctx.shadowColor = this.glowColor;
      ctx.shadowBlur = 25;
      ctx.strokeStyle = this.glowColor;
      ctx.lineWidth = 3;

      // Draw ship shape
      ctx.beginPath();
      ctx.moveTo(0, -this.radius);
      ctx.lineTo(this.radius * 0.7, this.radius);
      ctx.lineTo(0, this.radius * 0.4);
      ctx.lineTo(-this.radius * 0.7, this.radius);
      ctx.closePath();

      ctx.fillStyle = 'rgba(0,255,255,0.9)';
      ctx.fill();
      ctx.stroke();

      // Shield ring
      if(this.shield > 0) {
        const shieldAlpha = 0.6 + 0.4 * Math.sin(Date.now() / 100);
        ctx.strokeStyle = `rgba(0,255,255,${shieldAlpha.toFixed(2)})`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius + 8, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
      ctx.shadowBlur = 0;
    }
  }

  // === ASTEROID ===
  class Asteroid {
    constructor() {
      this.radius = randomRange(15, 40);
      this.x = Math.random() < 0.5 ? -this.radius - 10 : W + this.radius + 10;
      this.y = randomRange(0, H);
      this.speed = randomRange(1, 3);
      this.angle = 0;
      this.rotationSpeed = randomRange(-0.02, 0.02);
      this.vertices = [];
      this.vertexCount = randomRange(7, 12) | 0;
      for(let i=0; i<this.vertexCount; i++) {
        this.vertices.push(randomRange(this.radius*0.6, this.radius));
      }
      this.color = `hsl(${randomRange(20,50)}, 80%, 60%)`;
      // Direction vector toward center-ish (player will be near center)
      const toCenterX = W/2 - this.x;
      const toCenterY = H/2 - this.y;
      const mag = Math.hypot(toCenterX, toCenterY);
      this.vx = (toCenterX / mag) * this.speed;
      this.vy = (toCenterY / mag) * this.speed;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.angle += this.rotationSpeed;
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 2;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      for(let i=0; i < this.vertexCount; i++) {
        const angle = (i / this.vertexCount) * Math.PI * 2;
        const r = this.vertices[i];
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        if(i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    isOffscreen() {
      return (
        this.x < -this.radius*2 ||
        this.x > W + this.radius*2 ||
        this.y < -this.radius*2 ||
        this.y > H + this.radius*2
      );
    }
  }

  // === ENEMY SHIP ===
  class EnemyShip {
    constructor() {
      this.radius = 20;
      this.x = Math.random() < 0.5 ? -50 : W + 50;
      this.y = randomRange(0, H);
      this.speed = randomRange(2, 4);
      this.color = 'magenta';
      // Direction toward player start center
      const toCenterX = W/2 - this.x;
      const toCenterY = H/2 - this.y;
      const mag = Math.hypot(toCenterX, toCenterY);
      this.vx = (toCenterX / mag) * this.speed;
      this.vy = (toCenterY / mag) * this.speed;
      this.angle = 0;
    }
    update(player) {
      // Update velocity toward player current position for homing effect
      const toPlayerX = player.x - this.x;
      const toPlayerY = player.y - this.y;
      const mag = Math.hypot(toPlayerX, toPlayerY);
      const targetVX = (toPlayerX / mag) * this.speed;
      const targetVY = (toPlayerY / mag) * this.speed;

      // Smooth velocity lerp for natural movement
      this.vx = lerp(this.vx, targetVX, 0.08);
      this.vy = lerp(this.vy, targetVY, 0.08);

      this.x += this.vx;
      this.y += this.vy;

      this.angle = Math.atan2(this.vy, this.vx) + Math.PI/2;
    }
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);

      ctx.shadowColor = this.color;
      ctx.shadowBlur = 18;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 3;

      // Neon triangle ship (inverted)
      ctx.beginPath();
      ctx.moveTo(0, this.radius);
      ctx.lineTo(this.radius * 0.7, -this.radius);
      ctx.lineTo(-this.radius * 0.7, -this.radius);
      ctx.closePath();

      ctx.fillStyle = 'rgba(255, 0, 255, 0.9)';
      ctx.fill();
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.restore();
    }
    isOffscreen() {
      return (
        this.x < -this.radius*2 ||
        this.x > W + this.radius*2 ||
        this.y < -this.radius*2 ||
        this.y > H + this.radius*2
      );
    }
  }

  // === POWER-UP ===
  class PowerUp {
    constructor(type) {
      this.radius = 14;
      this.x = randomRange(this.radius, W - this.radius);
      this.y = randomRange(this.radius, H - this.radius);
      this.type = type; // 'shield' or 'speed'
      this.color = type === 'shield' ? 'deepskyblue' : 'lime';
      this.lifeTime = 900; // ~15 seconds at 60fps
      this.pulsePhase = 0;
    }
    update() {
      this.pulsePhase += 0.05;
      this.lifeTime--;
    }
    draw() {
      const pulse = 1 + 0.15 * Math.sin(this.pulsePhase);
      ctx.save();
      ctx.translate(this.x, this.y);

      ctx.shadowColor = this.color;
      ctx.shadowBlur = 15;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 3;

      // Draw glowing circle
      ctx.beginPath();
      ctx.arc(0, 0, this.radius * pulse, 0, Math.PI * 2);
      ctx.stroke();

      // Draw icon inside
      ctx.fillStyle = this.color;
      ctx.shadowBlur = 0;

      if(this.type === 'shield') {
        // Shield icon: a simple shield shape
        ctx.beginPath();
        ctx.moveTo(0, -7 * pulse);
        ctx.lineTo(5 * pulse, -3 * pulse);
        ctx.lineTo(5 * pulse, 4
